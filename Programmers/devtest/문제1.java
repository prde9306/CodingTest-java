package Programmers.devtest;

/**
 * 강의 왼쪽 편에서 1회용 보트를 이용하여 보급품 상자를 강의 오른쪽 편으로 전달하고자 합니다. 하지만 1회용 보트의 성능이 좋지 않아서 너무 많이 싣게 되면 보트가 망가져서 보트에 적재한 상자를 모두 잃게 됩니다.
 * 그런데 1회용 보트가 적재할 수 있는 상자의 수는 알려져 있지 않고, 보트 별로 다를 수가 있습니다.
 *
 * 최대한 빠른 시간에 원하는 개수의 상자를 강의 오른쪽으로 보내고자 하는 것이 목표인데, 이를 위해 다음과 같은 방식을 고안해 냅니다. 첫 번째 보트에는 1개의 상자를 실어서 보냅니다. 이게 성공하면 그다음부터는 실패할 때까지 그 이전에 보낸 상자 수의 2배씩 상자를 실어서 보냅니다. 만약 실패하게 되면 그다음에는 다시 1개의 상자부터 시작합니다.
 *
 * 각 1회용 보트의 최대 적재량이 들어 있는 배열 d (이 배열은 상자를 보내는 쪽에는 알려져 있지 않음)와 보내고자 하는 상자의 수 m이 주어질 때, 위에서 제시한 방법을 사용하여 상자를 보내는 경우 사용하게 되는 보트의 수를 return 하는 solution 함수를 완성해주세요.
 * 만약 위와 같은 방식을 사용했는데, 보트의 수가 부족하여 m개를 보내는데 실패하는 경우는 -1을 리턴합니다.
 *
 * 제한 사항
 * d의 길이는 1 이상 1,000 이하입니다.
 * d의 각 원소는 1 이상 6,000 이하의 자연수입니다.
 * m은 1 이상 200,000 이하의 자연수입니다.
 * 강의 왼쪽에 있는 보급품 상자의 수는 무제한입니다.
 * 입출력 예
 * d	m	result
 * [1,3,2,5,4]	6	5
 * [2,2,4,3]	6	3
 * [2,2,4,3]	8	-1
 * 입출력 예 설명
 * 입출력 예 #1
 * 보트가 5개가 있고, 6개의 상자를 보내고자 합니다. 첫 번째 보트에는 1개를 보내고 성공합니다. 두 번째 보트에는 2개를 보내고 성공합니다. 세 번째 보트에는 4개의 상자를 보내는데, 적재량이 2로 제한되어 있어서 실패합니다. 다시 네 번째 보트에는 1개의 상자를 보내고 성공합니다. 다섯 번째 보트에는 2개의 상자를 보내고 성공합니다. 총 6개의 상자를 보냈으므로 상자 보내기를 중단합니다. 총 5개의 보트가 사용되어서 5를 리턴합니다.
 *
 * 입출력 예 #2
 * 보트가 4개가 있고, 6개의 상자를 보내고자 합니다. 첫 번째 보트에는 1개를 보내고 성공합니다. 두 번째 보트에는 2개를 보내고 성공합니다. 세 번째 보트에는 4개의 상자를 보내고 성공합니다. 총 7개의 상자를 보냈는데, 목표인 6개를 달성했으므로 상자 보내기를 중단합니다. 총 3개의 보트가 사용되었기 때문에 3을 리턴합니다.
 *
 * 입출력 예 #3
 * 보트가 4개가 있고, 8개의 상자를 보내고자 합니다. 첫 번째 보트에는 1개를 보내고 성공합니다. 두 번째 보트에는 2개를 보내고 성공합니다. 세 번째 보트에는 4개의 상자를 보내고 성공합니다. 네 번째 보트에는 8개의 상자를 보내는데, 적재량이 3으로 제한되어 있어 실패합니다. 더 이상 보트가 없기 때문에 목표 달성에 실패하여 -1을 리턴합니다.
 */

public class 문제1 {
    public int solution(int[] d, int m) {
        int answer = 0;
    for(int i=0; i<d.length; i++){
        if(d[i]>=pow(i)){
            m= m-pow(i);
            answer++;
        }
    }else{

        }

        }



}